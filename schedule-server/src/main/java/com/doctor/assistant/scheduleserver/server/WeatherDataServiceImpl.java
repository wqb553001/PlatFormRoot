package com.doctor.assistant.scheduleserver.server;import com.doctor.assistant.scheduleserver.entity.WeatherResponse;import com.fasterxml.jackson.databind.ObjectMapper;import com.netflix.discovery.EurekaEventListener;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;import java.io.*;import java.util.concurrent.TimeUnit;import java.util.zip.GZIPInputStream;@Servicepublic class WeatherDataServiceImpl implements WeatherDataService {    @Resource(name = "restTemplate")    private RestTemplate restTemplate;    @Resource(name = "jedisRedisTemplate")    private RedisTemplate stringRedisTemplate;    private final Logger logger = LoggerFactory.getLogger(WeatherDataServiceImpl.class);    private final String WEATHER_API = "http://wthrcdn.etouch.cn/weather_mini";    /**     * 缓存超时时间     */    private final Long TIME_OUT = 1800L;    @Override    public WeatherResponse getDataByCityId(String cityId) {        String uri = WEATHER_API + "?citykey=" + cityId;        return this.doGetWeatherData(uri);    }    @Override    public WeatherResponse getDataByCityName(String cityName) {        String uri = WEATHER_API + "?city=" + cityName;        return this.doGetWeatherData(uri);    }    private WeatherResponse doGetWeatherData(String uri) {        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();        //将调用的uri作为缓存的key        String strBody = null;        //先查缓存，没有找到查服务        if (!stringRedisTemplate.hasKey(uri)) {            logger.info("redis缓存中，未找到 key，需访问网络资源。key ：" + uri);            ResponseEntity<String> response = restTemplate.getForEntity(uri, String.class);            if (response.getStatusCodeValue() == 200) {                strBody = response.getBody();            }            logger.info("将 key 放入redis缓存中 key：" + uri);            ops.set(uri, strBody, TIME_OUT, TimeUnit.SECONDS);        } else {            logger.info("redis缓存中，找到 key，直接从 redis 中读取：key= " + uri + ",value= " + ops.get(uri));            strBody = ops.get(uri);        }        ObjectMapper mapper = new ObjectMapper();        WeatherResponse weather = null;        try {            weather = mapper.readValue(strBody, WeatherResponse.class);        } catch (IOException e) {            e.printStackTrace();        }        return weather;    }    @Override    public void syncDataByCityId(String cityId) {        String uri = WEATHER_API + "?citykey=" + cityId;        saveWeatherData(uri);    }    private void saveWeatherData(String uri) {        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();        String strBody = null;        ResponseEntity<String> response = restTemplate.getForEntity(uri, String.class);        if (response.getStatusCodeValue() == 200) {            strBody = response.getBody();        }        ops.set(uri, strBody, TIME_OUT, TimeUnit.SECONDS);    }}